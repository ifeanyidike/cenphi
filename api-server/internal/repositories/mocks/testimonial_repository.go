// Code generated by mockery v2.53.1. DO NOT EDIT.

package mocks

import (
	context "context"

	models "github.com/ifeanyidike/cenphi/internal/models"
	mock "github.com/stretchr/testify/mock"

	repositories "github.com/ifeanyidike/cenphi/internal/repositories"

	sql "database/sql"

	uuid "github.com/google/uuid"
)

// TestimonialRepository is an autogenerated mock type for the TestimonialRepository type
type TestimonialRepository struct {
	mock.Mock
}

// BatchUpsert provides a mock function with given fields: ctx, testimonials, db
func (_m *TestimonialRepository) BatchUpsert(ctx context.Context, testimonials []models.Testimonial, db *sql.DB) error {
	ret := _m.Called(ctx, testimonials, db)

	if len(ret) == 0 {
		panic("no return value specified for BatchUpsert")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []models.Testimonial, *sql.DB) error); ok {
		r0 = rf(ctx, testimonials, db)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CountByWorkspaceID provides a mock function with given fields: ctx, workspaceID, filter, db
func (_m *TestimonialRepository) CountByWorkspaceID(ctx context.Context, workspaceID uuid.UUID, filter models.TestimonialFilter, db repositories.DB) (int, error) {
	ret := _m.Called(ctx, workspaceID, filter, db)

	if len(ret) == 0 {
		panic("no return value specified for CountByWorkspaceID")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, models.TestimonialFilter, repositories.DB) (int, error)); ok {
		return rf(ctx, workspaceID, filter, db)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, models.TestimonialFilter, repositories.DB) int); ok {
		r0 = rf(ctx, workspaceID, filter, db)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, models.TestimonialFilter, repositories.DB) error); ok {
		r1 = rf(ctx, workspaceID, filter, db)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Create provides a mock function with given fields: ctx, entity, db
func (_m *TestimonialRepository) Create(ctx context.Context, entity *models.Testimonial, db repositories.DB) error {
	ret := _m.Called(ctx, entity, db)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.Testimonial, repositories.DB) error); ok {
		r0 = rf(ctx, entity, db)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Delete provides a mock function with given fields: ctx, id, db
func (_m *TestimonialRepository) Delete(ctx context.Context, id uuid.UUID, db repositories.DB) error {
	ret := _m.Called(ctx, id, db)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, repositories.DB) error); ok {
		r0 = rf(ctx, id, db)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteByID provides a mock function with given fields: ctx, id, db
func (_m *TestimonialRepository) DeleteByID(ctx context.Context, id uuid.UUID, db repositories.DB) error {
	ret := _m.Called(ctx, id, db)

	if len(ret) == 0 {
		panic("no return value specified for DeleteByID")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, repositories.DB) error); ok {
		r0 = rf(ctx, id, db)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FetchByCustomerEmail provides a mock function with given fields: ctx, workspaceID, email, db
func (_m *TestimonialRepository) FetchByCustomerEmail(ctx context.Context, workspaceID uuid.UUID, email string, db repositories.DB) ([]models.Testimonial, error) {
	ret := _m.Called(ctx, workspaceID, email, db)

	if len(ret) == 0 {
		panic("no return value specified for FetchByCustomerEmail")
	}

	var r0 []models.Testimonial
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, repositories.DB) ([]models.Testimonial, error)); ok {
		return rf(ctx, workspaceID, email, db)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, repositories.DB) []models.Testimonial); ok {
		r0 = rf(ctx, workspaceID, email, db)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Testimonial)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string, repositories.DB) error); ok {
		r1 = rf(ctx, workspaceID, email, db)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FetchByID provides a mock function with given fields: ctx, id, db
func (_m *TestimonialRepository) FetchByID(ctx context.Context, id uuid.UUID, db repositories.DB) (*models.Testimonial, error) {
	ret := _m.Called(ctx, id, db)

	if len(ret) == 0 {
		panic("no return value specified for FetchByID")
	}

	var r0 *models.Testimonial
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, repositories.DB) (*models.Testimonial, error)); ok {
		return rf(ctx, id, db)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, repositories.DB) *models.Testimonial); ok {
		r0 = rf(ctx, id, db)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Testimonial)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, repositories.DB) error); ok {
		r1 = rf(ctx, id, db)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FetchByTags provides a mock function with given fields: ctx, workspaceID, tags, matchAll, db
func (_m *TestimonialRepository) FetchByTags(ctx context.Context, workspaceID uuid.UUID, tags []string, matchAll bool, db repositories.DB) ([]models.Testimonial, error) {
	ret := _m.Called(ctx, workspaceID, tags, matchAll, db)

	if len(ret) == 0 {
		panic("no return value specified for FetchByTags")
	}

	var r0 []models.Testimonial
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, []string, bool, repositories.DB) ([]models.Testimonial, error)); ok {
		return rf(ctx, workspaceID, tags, matchAll, db)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, []string, bool, repositories.DB) []models.Testimonial); ok {
		r0 = rf(ctx, workspaceID, tags, matchAll, db)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Testimonial)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, []string, bool, repositories.DB) error); ok {
		r1 = rf(ctx, workspaceID, tags, matchAll, db)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FetchByWorkspaceID provides a mock function with given fields: ctx, workspaceID, filter, db
func (_m *TestimonialRepository) FetchByWorkspaceID(ctx context.Context, workspaceID uuid.UUID, filter models.TestimonialFilter, db repositories.DB) ([]models.Testimonial, error) {
	ret := _m.Called(ctx, workspaceID, filter, db)

	if len(ret) == 0 {
		panic("no return value specified for FetchByWorkspaceID")
	}

	var r0 []models.Testimonial
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, models.TestimonialFilter, repositories.DB) ([]models.Testimonial, error)); ok {
		return rf(ctx, workspaceID, filter, db)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, models.TestimonialFilter, repositories.DB) []models.Testimonial); ok {
		r0 = rf(ctx, workspaceID, filter, db)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Testimonial)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, models.TestimonialFilter, repositories.DB) error); ok {
		r1 = rf(ctx, workspaceID, filter, db)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FetchMostRecent provides a mock function with given fields: ctx, workspaceID, limit, db
func (_m *TestimonialRepository) FetchMostRecent(ctx context.Context, workspaceID uuid.UUID, limit int, db repositories.DB) ([]models.Testimonial, error) {
	ret := _m.Called(ctx, workspaceID, limit, db)

	if len(ret) == 0 {
		panic("no return value specified for FetchMostRecent")
	}

	var r0 []models.Testimonial
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, int, repositories.DB) ([]models.Testimonial, error)); ok {
		return rf(ctx, workspaceID, limit, db)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, int, repositories.DB) []models.Testimonial); ok {
		r0 = rf(ctx, workspaceID, limit, db)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Testimonial)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, int, repositories.DB) error); ok {
		r1 = rf(ctx, workspaceID, limit, db)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FetchTopRated provides a mock function with given fields: ctx, workspaceID, limit, db
func (_m *TestimonialRepository) FetchTopRated(ctx context.Context, workspaceID uuid.UUID, limit int, db repositories.DB) ([]models.Testimonial, error) {
	ret := _m.Called(ctx, workspaceID, limit, db)

	if len(ret) == 0 {
		panic("no return value specified for FetchTopRated")
	}

	var r0 []models.Testimonial
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, int, repositories.DB) ([]models.Testimonial, error)); ok {
		return rf(ctx, workspaceID, limit, db)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, int, repositories.DB) []models.Testimonial); ok {
		r0 = rf(ctx, workspaceID, limit, db)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Testimonial)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, int, repositories.DB) error); ok {
		r1 = rf(ctx, workspaceID, limit, db)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetByID provides a mock function with given fields: ctx, id, db
func (_m *TestimonialRepository) GetByID(ctx context.Context, id uuid.UUID, db repositories.DB) (*models.Testimonial, error) {
	ret := _m.Called(ctx, id, db)

	if len(ret) == 0 {
		panic("no return value specified for GetByID")
	}

	var r0 *models.Testimonial
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, repositories.DB) (*models.Testimonial, error)); ok {
		return rf(ctx, id, db)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, repositories.DB) *models.Testimonial); ok {
		r0 = rf(ctx, id, db)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Testimonial)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, repositories.DB) error); ok {
		r1 = rf(ctx, id, db)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MarkAsVerified provides a mock function with given fields: ctx, id, verificationMethod, verificationData, db
func (_m *TestimonialRepository) MarkAsVerified(ctx context.Context, id uuid.UUID, verificationMethod models.VerificationType, verificationData map[string]interface{}, db repositories.DB) error {
	ret := _m.Called(ctx, id, verificationMethod, verificationData, db)

	if len(ret) == 0 {
		panic("no return value specified for MarkAsVerified")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, models.VerificationType, map[string]interface{}, repositories.DB) error); ok {
		r0 = rf(ctx, id, verificationMethod, verificationData, db)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Update provides a mock function with given fields: ctx, entity, id, db
func (_m *TestimonialRepository) Update(ctx context.Context, entity *models.Testimonial, id uuid.UUID, db repositories.DB) error {
	ret := _m.Called(ctx, entity, id, db)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.Testimonial, uuid.UUID, repositories.DB) error); ok {
		r0 = rf(ctx, entity, id, db)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateMetrics provides a mock function with given fields: ctx, id, viewCount, shareCount, conversionCount, db
func (_m *TestimonialRepository) UpdateMetrics(ctx context.Context, id uuid.UUID, viewCount int, shareCount int, conversionCount int, db repositories.DB) error {
	ret := _m.Called(ctx, id, viewCount, shareCount, conversionCount, db)

	if len(ret) == 0 {
		panic("no return value specified for UpdateMetrics")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, int, int, int, repositories.DB) error); ok {
		r0 = rf(ctx, id, viewCount, shareCount, conversionCount, db)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateStatus provides a mock function with given fields: ctx, id, status, db
func (_m *TestimonialRepository) UpdateStatus(ctx context.Context, id uuid.UUID, status models.ContentStatus, db repositories.DB) error {
	ret := _m.Called(ctx, id, status, db)

	if len(ret) == 0 {
		panic("no return value specified for UpdateStatus")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, models.ContentStatus, repositories.DB) error); ok {
		r0 = rf(ctx, id, status, db)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Upsert provides a mock function with given fields: ctx, testimonial, db
func (_m *TestimonialRepository) Upsert(ctx context.Context, testimonial models.Testimonial, db repositories.DB) error {
	ret := _m.Called(ctx, testimonial, db)

	if len(ret) == 0 {
		panic("no return value specified for Upsert")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, models.Testimonial, repositories.DB) error); ok {
		r0 = rf(ctx, testimonial, db)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewTestimonialRepository creates a new instance of TestimonialRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTestimonialRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *TestimonialRepository {
	mock := &TestimonialRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
